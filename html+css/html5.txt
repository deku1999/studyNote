注意，h5一些标签直接就具有宽高这种属性直接就可以通过标签属性定义而不是必须要用css，
source标签：定义媒介源
1.视频，video标签，标签中插入的内容浏览器不会显示，不过可以通过source标签插入多种格式的视频文件以适配不同的浏览器，浏览器将使用第一个可识别的格式。例如
<video width="320" height="240" controls="controls">
  <source src="movie.ogg" type="video/ogg">
  <source src="movie.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>，当然也可以直接在标签内部用url链接，这条规则也适用于audio音频标签
属性		值		描述
autoplay		autoplay		如果出现该属性，则视频在就绪后马上播放。
controls		controls		如果出现该属性，则向用户显示控件，比如播放按钮。
height		pixels		设置视频播放器的高度。
loop		loop		如果出现该属性，则当媒介文件完成播放后再次开始播放。
preload		preload		如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性
src		url		要播放的视频的 URL。
width		pixels		设置视频播放器的宽度。
当然也有一些dom方法，例如play()播放，pause()暂停，e.paused可以返回视频元素的播放状态，正在播放返回true否则false

2.音频，audio标签，跟video标签用法很像
属性		值		描述
autoplay		autoplay		如果出现该属性，则音频在就绪后马上播放。
controls		controls		如果出现该属性，则向用户显示控件，比如播放按钮。
loop		loop		如果出现该属性，则每当音频结束时重新开始播放。
preload		preload		如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性
src		url		要播放的音频的 URL。

3.拖放
（1）即抓取对象以后拖到另一个位置，在html5中，拖放是标准的一部分，任何元素都能够拖放
首先给想要被拖动元素的draggable属性设为true
（2）然后规定当元素被拖动时发生什么，触发事件ondragstart，一般也是在被托元素中通过js函数调用，如调用函数drag(event)，function drag（ev）{ev.dataTransfer.setData("Text",ev,target.id);}，这个函数中通过dataTransfer.setData()方法设置被拖数据的数据类型和值，在这个例子中数据类型就是Text，值就是可拖动的元素id
（3）放到何处-ondragover，函数有形参ev，给被放置元素设置
ondragover事件规定在何处放置被拖放的数据，因为元素默认不允许被放置，所以需要先阻止元素默认的处理方式，通过函数调用事件的阻止默认方法
，ev.preventDefault()
（4）进行放置-ondrop，也是给被放置元素设置，也有形参ev
当放置被拖数据时赋予它一个事件，里面的代码为
ev.preventDefault();
var data = ev.dataTransfet.getData("Text")
ev.target.appendChild(document.getElementById(data))
注：2，3，4都是元素被拖动时才会触发的事件

4.画布
通过canvas标签可以定义一个画布，之后可以在其上面画各式各样的图形，包括放图片等，暂不细讲

5.svg，暂不细讲
svg指可伸缩矢量图形，用于定义网格的基于矢量的图形。svg使用xml格式定义图形，svg图像在放大或改变尺寸的情况下对其图形质量不会有损失。svg是万维网联盟的标准。

6.canvas与svg
Canvas
依赖分辨率
不支持事件处理器
弱的文本渲染能力
能够以 .png 或 .jpg 格式保存结果图像
最适合图像密集型的游戏，其中的许多对象会被频繁重绘
SVG
不依赖分辨率
支持事件处理器
最适合带有大型渲染区域的应用程序（比如谷歌地图）
复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
不适合游戏应用

7.地理定位，暂不细讲
html5可以使用GeolocationAPI来获得用户的地理位置

8.web存储
指在客户端存储数据，目前h5提供了两种方法，以前是用cookie
loaclStorage，存储的数据没有时间限制，即使一年之后也可用
sessionStorage，只针对一个session的数据存储，打个比方就是你关闭网页这个数据就自动清空了，在你打开这个网页期间进行存储

9.应用缓存，更详细内容请自行上网查询
HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。
应用程序缓存为应用带来三个优势：
离线浏览 - 用户可在应用离线时使用它们
速度 - 已缓存资源加载得更快
减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。
如需启用应用程序缓存程序，要现在html中包含manifest属性，如
<html manifest="demo.appcache">
...
</html>
每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。
manifest 文件的建议的文件扩展名是：".appcache"。
请注意，manifest 文件需要配置正确的 MIME-type，即 "text/cache-manifest"。必须在 web 服务器上进行配置。
manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。
manifest 文件可分为三个部分：
CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

10.web workers，是指运行在后台的js，不影响页面的性能
暂不详细介绍，请自己查阅

11.服务器发送事件，Server-Sent event允许网页获得来自服务器的更新
EventSource对象用于接收服务器发送事件通知，不详解请自行查阅

12.表单，暂不详解
（1）html5新增了一些输入类型：
email
url
number
range
Date pickers (date, month, week, time, datetime, datetime-local)：输入类型为日期
search
color
（2）表单元素：
datalist
keygen
output
（3）表单属性：
新的form属性：
autocomplete：规定form或input域应该拥有自动完成功能
novalidate：规定在提交表单时不应该验证form或input域
新的input属性：
autocomplete
autofocus
form
form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)
height 和 width
list
min, max 和 step
multiple
pattern (regexp)：很好用，可以直接写正则表达式来对输入进行限制
placeholder：很好用，可以根据
required：规定在提交之前填写输入域（不能为空）

